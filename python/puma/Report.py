#Functions for making reports
#created by T. Morgan 12/3/2019

import os
import pytz
import datetime

from netCDF4 import Dataset
import pandas as pd
import sys
import shutil

import puma.plot as pplot

import puma.tex as ptex
import puma.fuel as pfuel
import puma.temperature as ptemp

file_path = os.path.abspath(os.path.dirname(__file__))
sys.path.append(os.path.join(file_path,'..'))

class Report:
    '''Report class contains metric attributes ported to the report document and the functions to generate them from a unified netcdf
    '''
    def __init__(self,start,end,title,nc,houses,fuel_price):
        '''

        :param start: datetime AKST for start of dateset to include in metric calculations
        :param end:  datetime AKST for end of dateset to include in metric calculations
        :param title: title to use to name pdf
        :param nc: Unified netcdf
        :param houses: A list of houses to calculate metrics for
        :param fuel_price can be a float value or pd.Series with datetime index
        '''
        self.start = start #start date for the report period
        self.end = end  #end date for the report period
        self.titlePrefix = title #a prefix to destinguish this report from others for the same list of stoves
        self.houses = houses  # list of house objects with 1 or more stoves to include in metrics
        self.tip_no = 0 #tip number associated with a tip list
        stoves =   list(set([s.name for s in self.mergeStoves()]))
        stoves.sort()
        self.name= "-".join(stoves) #report name autogenerated from stove list
        self.unified_nc_file = nc #netcdf file containing data to use in report
        self.gallons = 0  #sum of all gallons consumed during report period
        self.total_clicks = 0   #total number of clicks recorded during report period (not meaining full for multi-stove households)
        self.total_cost=0   #total cost of fuel based on gallons (see below metric) and input fuel price
        self.ave_fuel_per_day = (0,0) #average and standard error of gallons per day during the report period
        self.gph = pd.Series()  #pandas series of average gallons per hour during report time period
        self.ave_gallons_by_hour = pd.Series() #average gallons per hour for each our in a 24 hour period
        self.ave_gph = (0,0)    #average and standard error of gallons per hour during report time period
        self.gallons_per_ft = 0     #total gallons (estimate or actual) for entire report time period per square ft
        self.neighborhoodTotalUsage = 0     #total gallons used by entire neighborhood (exlcuding report houses)
        self.neighbor_usage_per_area = (0,0) #mean and standard deviation - should be CI and standard error
        self.ave_MonthlyindoorT = (0, 0)    #average indoor temperature for entire report time period
        self.ave_MonthlyoutdoorT = (0, 0)   #average outdoor temperature for entire report time period
        self.fuel_price = fuel_price    #fuel price, set by user
        self.date_duration = 0      #time delta of the report time period
        self.days_monitored = (0,0) #tuple actual time and time in days covered by actual dataset (less than duration if there are missing values)
        self.neighborhood = []  #list of Houses in the neighborhood
        self.total_gallons = 0  #the total gallons consumed in the report time period. If dataset has missing data this value is extrapolated from average consumption rates
        self.gphddBym = pd.Series()  #gallons per hour per hdd by month for all months included in dataset (including prior to report period)
        self.ave_cost_per_day=0     #average cost per day based on gallons (not extrapolated), days monitored and fuel price
        self.prog_usage = 0     #proportion of usage compared to previous time interval
        self.dataFlag = 0       #0, or 1. 1 indicates total gallons is an estimate because data was missing
    def mergeStoves(self):
        '''get a list of stoves to extract data from based the the stoves that are
        associated with each house included in report'''
        self.stoves = []
        self.stoves = [self.stoves + h.stoves for h in self.houses][0]
        return self.stoves
    def generateMetrics(self):
        '''create a dataframe for the report time period and generate report metrics based on the dataset'''
        self.area = sum([float(house.area) for house in self.houses])  # total area metrics are being calculated for
        self.report_duration = self.end - self.start
        self.initDate = self.setInitDate()
        #filter the dataset to the portion required for this report
        self.filtered_df,self.indoorTData = self.filterDataset()

        self.getTip()  # set a tip to display

        if len(self.filtered_df) > 0:
            self.date_duration = pd.to_timedelta(self.indoorTData.index[-1] - self.indoorTData.index[0],
                                                 unit='day') #range that data was actually collected for
            self.days_monitored  =self.getDaysMonitored() #this is actual duration that there is data for

            #in the case of multi month report temperatures will be by month
            self.ave_MonthlyindoorT, self.ave_DailyIndoorT = self.getAveTemperature(self.indoorTData['inT']) #average of indoor Temperature for report time period
            self.ave_MonthlyoutdoorT,self.ave_DailyOutdoorT = self.getAveTemperature(self.hourlyOutdoorTemperature) #average of outdoor Temperature for report time period
            self.actualGallonsByMonth = self.getActualGallonsByMonth()
            self.gallons = self.filtered_df.fuel_consumption.sum() #recorded total consumption in gallons

            self.gph = pfuel.gallonsPerHour(self.filtered_df.fuel_consumption) #gph for all hours in the data range
            self.ave_gph = self.getAveGPH()  #overall average gph, and standard error
            self.ave_gallons_by_hour = self.getAveGPH_byHour() #average gph, and standard error by hour of day
            self.fuel_by_day = self.getFuelByDay()
            self.ave_fuel_per_day = self.getAveFuelPerDay() #average and standard error per day over data range

            # days_monitored is a tuple, first arg is timedelta , sencond is days integer
            self.ave_cost_per_day = self.getAveCostPerDay() #average of data range

            # if the monitored days is within 12 hours of the total report duration then use the actual total_gallons
            # otherwise produces a hdd corrected estimate.

            self.setTotals()

            #metrics based on total gallons
            self.gallons_per_ft = self.getGallonsPerFt()  # use total gallons for entire report period


        if self.days_monitored[0] < self.date_duration:
            #self.gphddBym = self.getGphddBym()

            self.setProgUsage()
        if self.neighborhood:  # if a neighborhood is provided use it to create comparison metrics
            self.compareNeighbors()

        return

    def getActualGallonsByMonth(self):
        gpd, gpm = pfuel.gallons_per_day_and_per_month(self.filtered_df, 'fuel_consumption')
        gpm = gpd.groupby(pd.Grouper(freq='M')).sum(min_count=1)
        return gpm
    def setInitDate(self):
        def toUtc(d):
            d = datetime.datetime.strptime(d, "%m/%d/%Y")
            mytimezone = pytz.timezone('US/Alaska')
            if d.tzinfo == None:
                d= mytimezone.localize(d)
                return d
            elif d.tzinfo == mytimezone:
                return d
            else:
                return d.astimezone(mytimezone)
        idates = []
        for house in self.houses:
            for stove in house.stoves:
                idates = idates + stove.initiation

        initDate = toUtc(min([d for d in idates]))
        return initDate

    def removeShortMonths(self,df):

        d = df[pd.notnull(df['fuel_consumption'])] # only days with fuel data

        dsum = d['fuel_consumption'].groupby(pd.Grouper(freq="D")).sum()
        dcount = dsum.groupby(pd.Grouper(freq="M")).count() #if there are fewer than 15 days we don't want to extrapolate month long information
        dcount.name = 'day_count'
        if (dcount.index.tzinfo is None):
            dcount.index = dcount.index.tz_localize(df.index.tz)

        dcount = pd.DataFrame(dcount, dcount.index)
        df2 = df.reset_index().merge(dcount,how='left', left_on=df.index.date, right_on=dcount.index.date).set_index('index')
        df2.index = df.index
        df2['day_count'] = df2['day_count'].bfill()
        cleaned = df2[df2['day_count'] >= 15] #drop months with fewer than 15 days of data of no data at all
        cleaned = cleaned.drop(['day_count', 'key_0'], axis=1)
        return cleaned
    def setTotals(self):
        if (datetime.timedelta(self.days_monitored[1]) < (self.report_duration + datetime.timedelta(hours=12))) & (
                datetime.timedelta(self.days_monitored[1]) > (self.report_duration - datetime.timedelta(hours=12))):
            self.total_gallons = self.gallons
            self.total_cost = self.getTotalCost()  # estimated cost (actual if no missing data)
        else:
            self.total_gallons = self.getEstimatedTotalGallons()
            self.total_cost = self.total_gallons * self.fuel_price.mean() # estimated cost (actual if no missing data)
            self.dataFlag = 1  # if flag is one then gallons is an estimate and not measured value

    def setProgUsage(self):
        if len(self.estimatedGallonsByMonth) > 1:
            # progress is defined as the difference between the last value and the previous value divided by the previous value
            # proportion of last value that the current value is
            current = self.estimatedGallonsByMonth[(self.estimatedGallonsByMonth.index.month == self.start.month) & (self.estimatedGallonsByMonth.index.year == self.start.year)]

            previousMonth = self.estimatedGallonsByMonth[(self.estimatedGallonsByMonth.index.month == (self.start - pd.to_timedelta('1 d')).month) & (self.estimatedGallonsByMonth.index.year == (self.start - pd.to_timedelta('1 d')).year)]
            try:
                self.prog_usage = float((previousMonth.values - current.values) / previousMonth.values)
            except:
                self.prog_usage = 0
        else:
            self.prog_usage = 0

    def getGphddBym(self):
        return pfuel.weather_adjusted_gallons_consumed_per_month(self.filtered_df, self.hourlyOutdoorTemperature,
                                                                 'fuel_consumption')

    def getTotalCost(self):
        return self.total_gallons * self.fuel_price
    def getEstimatedTotalCost(self):
        return self.estimated_total_gallons * self.fuel_price
    def getGallonsPerFt(self):
        return self.total_gallons / self.area
    def getFuelByDay(self):
        return self.filtered_df.fuel_consumption.groupby(pd.Grouper(freq='D')).sum(min_count=1)
    def getAveCostPerDay(self):
        return self.ave_fuel_per_day[0] * self.fuel_price
    def getAveTemperature(self, t_data):
        '''get the daily and monthly average value for a specified field
        :return: df --dataframe of averages by month
        :return dg -- pd.Series of mean daily values'''
        average_dailyTemperature = t_data.groupby(pd.Grouper(freq ='D')).mean()
        ave = t_data.groupby(pd.Grouper(freq='M')).mean()
        sem = t_data.groupby(pd.Grouper(freq='M')).sem()
        df = pd.concat([ave, sem], axis=1)
        df.columns = ['ave','sem']
        return df, average_dailyTemperature
    def getHourlyTemperature(self,df,t_field):
        hourly = df[t_field].groupby(pd.Grouper(freq='h')).mean()
        return hourly
    def getAveGPH_byHour(self):
        '''average gallons per hour for each hour interval in a day - hours 0-23
        :return pandas series with hour index'''
        m = self.gph.groupby(pd.Grouper(freq='H')).mean()
        return m
    def getAveGPH(self):
        '''get the average gallons per hour over the report period
        return: tuple of float average and standard error of gallons per hour for the report period'''
        m = float(self.gph.mean())
        s = float(self.gph.sem())
        return (m,s)
    def getAveFuelPerDay(self):
        '''calculate the average fuel consumed per day and standard error
        return: tuple of float average and mean daily gallons per day'''
        gpd,gpm = pfuel.gallons_per_day_and_per_month(self.filtered_df, 'fuel_consumption')
        ave_gpd = float(gpd.mean()) # average gpd, and standard error
        sem_gpd = float(gpd.sem())
        return (ave_gpd, sem_gpd)
    def make_report(self):
        '''function calls for generating tex report with figures'''
        if self.title != None: #if a title is provided the report will get created, otherwise it is just for metrics
            try:
                os.mkdir(self.name)
            except:
                pass

        self.generateMetrics()

        self.makePlots()

        self.writeReport()
    def makePlots(self):
        '''plots are specific ot report subclass'''
        pass
    def getGallonsPerHour(self):
        '''mean gallons per hour by hour
        :returns pandas series'''
        return self.filtered_df.fuel_consumption.groupby(pd.Grouper(freq='H')).agg('mean','sem')
    def getTip(self):
        '''tips are report subclass specific'''
        pass
    def writeReport(self):
        '''report text and layout is subclass specific'''
        pass
    def compare2Neighbors(self):
        '''Generate neighborhood metrics based on Neighborhood defined in self.neighborhood
        self.houses are excluded from the neighborhood metrics'''
        self.neighborhoodTotalUsage = self.neighborhood.getTotalGallons(self.houses)
        self.neighbor_usage_per_area = self.neighborhood.getMeanGallonsPerFt(self.houses) #self.houses are not included in neighborhood
        self.neighbor_area = self.neighborhood.getTotalArea(self.houses)
    def setNeighborhood(self,neighborhood):
        #setter for neighborhood
        self.neighborhood = neighborhood
    def getDaysMonitored(self):
        '''Calculate the atcual time that is contained in the dataset, and round
        to day cout. monitored days is the actual number of days we have usable data
        not the duration that the dataset is suppose to cover. A day only counts if it is part of a month with atleast 15 days of data.
        :return timedelta, integer number of days with atleast 6 hours of data'''

        time =self.filtered_df[['stove']]
        #time['time'] = time.index
        stove_groups= time.groupby(['stove'])
        dailydf = pd.DataFrame()
        for g in stove_groups.groups.keys():
            differ = pd.Series(stove_groups.groups[g])
            differ.index = differ
            duration = differ.groupby(pd.Grouper(freq = 'D')).diff()
            duration.loc[pd.isnull(duration)] = pd.to_timedelta('0h')
            daily = duration.groupby(pd.Grouper(freq = 'D')).sum()
            dailydf = pd.concat([dailydf, daily], axis=1, join='outer')
        time = dailydf.max(axis=1)
        time = time.dt.round('H') #round to nearest hours
        actualTime = time.sum()
        days = len(time[time > pd.to_timedelta(0.25, unit='day')]) #threshhold of 6 hours of data to be included in metrics
        return actualTime,days

    def getDaysWithLessThan12hours(self,filtered_df):
        time = filtered_df.loc[(pd.notnull(filtered_df['inT']) | pd.notnull(filtered_df['fuel_consumption'])),['stove']]
        # time['time'] = time.index
        stove_groups = time.groupby(['stove'])
        dailydf = pd.DataFrame()
        for g in stove_groups.groups.keys():
            differ = pd.Series(stove_groups.groups[g])
            differ.index = differ
            duration = differ.groupby(pd.Grouper(freq='D')).diff()
            duration.loc[pd.isnull(duration)] = pd.to_timedelta('0h')
            daily = duration.groupby(pd.Grouper(freq='D')).sum(min_count=2)
            dailydf = pd.concat([dailydf, daily], axis=1, join='outer')
        dailydf['dur'] = dailydf.max(axis=1)
        dailydf['dur'] = dailydf['dur'].dt.round('H')  # round to nearest hours
        dailydf.loc[pd.isnull(dailydf['dur']),'dur'] = pd.to_timedelta('0h')
        return dailydf.loc[(dailydf['dur'] < pd.to_timedelta(0.4, unit='day')) | (pd.isnull(dailydf['dur'])),'dur']

    def getEstimatedTotalGallons(self):
        estimatedGallonsByMonth = self.getEstimatedGallons()
        self.estimatedGallonsByMonth      = estimatedGallonsByMonth[estimatedGallonsByMonth['day_count'] > 0]
        return self.estimatedGallonsByMonth['total_fuel'].sum()  # the total is the sum of all days (actual and estimated)
    def getEstimatedTotalCost(self):

        return self.getTotalCost()
    def getEstimatedGallons(self):
        '''estimate gallons for days without data
          and sum both the actual and estimated to produce an estimated total
          :returns float value of total by month'''

        hdd = ptemp.heat_degree_day(self.hourlyOutdoorTemperature) #returns a series of hdd values by day with actual gallons used per day
        hdd = hdd[:self.filtered_df.index[-1]]
        #gpd = pfuel.gallons_per_day_and_per_month(self.filtered_df, 'fuel_consumption')[0] #the first value in the returned tuple is dataframe by day
        gpd = pfuel.gallons_per_day_and_per_month(self.indoorTData, 'fuel_consumption')[0]
        gpd_hdd = pd.concat([gpd,hdd],axis=1)

        gpd_hdd['gphdd'] = gpd_hdd['fuel_consumption'] / gpd_hdd['hdd']
        actual = gpd_hdd[pd.notnull(gpd_hdd['gphdd'])]
        self.actualAverageGallonsPerHDDByMonth  = actual['gphdd'].groupby(pd.Grouper(freq='M')).agg(['mean','count'])
        self.actualAverageGallonsPerHDDByMonth.columns = ['average_gphdd','sample_size']
        gpd_hdd['month'] = gpd_hdd.index.to_period('M')
        ave_gpd_hdd_by_month = gpd_hdd['gphdd'].groupby(pd.Grouper(freq='M')).agg(['mean', 'count'],min_count=10)
        #drop any estimates created from fewer than 10 days
        ave_gpd_hdd_by_month = ave_gpd_hdd_by_month[ave_gpd_hdd_by_month['count'] > 10]
        ave_gpd_hdd_by_month['month'] = ave_gpd_hdd_by_month .index.to_period('M')
        #fill gphdd column with average gpdhdd where hdd is present but gphdd is missing
        #join the 2 datasets
        gpd_hdd2 = pd.merge(gpd_hdd, ave_gpd_hdd_by_month, on='month', how='left').drop(['count'],axis=1)
        gpd_hdd2.index = gpd_hdd.index

        gpd_hdd2.loc[pd.isnull(gpd_hdd2['gphdd']),'gphdd'] = gpd_hdd2.loc[pd.isnull(gpd_hdd2['gphdd']),'mean']
        #if its still null fill with overall average but hdd has a value
        gpd_hdd2.loc[pd.isnull(gpd_hdd2['gphdd']) & pd.notnull(gpd_hdd2['hdd']),'gphdd']  =  gpd_hdd['gphdd'].mean()

        #fill missing fuel consumption days with hdd * average gphdd
        gpd_hdd2.loc[pd.isnull(gpd_hdd2['fuel_consumption']),'fuel_consumption'] = gpd_hdd2.loc[pd.isnull(gpd_hdd2['fuel_consumption']),'gphdd'] * gpd_hdd2.loc[pd.isnull(gpd_hdd2['fuel_consumption']),'hdd']
        gpd_hdd2.loc[gpd_hdd2['fuel_consumption'] < 0.13, 'fuel_consumption'] = 0    #compensate for error in hadd average. No fuel usage estimated if less than 5 hdd and fuel usage not recorded

        #there are still missing days that have not been estimated due to missing hdd and missing mean values for the month.
        #to fill these data we calcluate a new mean based on data filled from above and fill remaining nas with these values.
        #monthly means
        mm = gpd_hdd2[['fuel_consumption']].groupby(pd.Grouper(freq='M')).mean()
        mm.columns = ['mm']
        mm['month'] =  mm.index.to_period('M')
        overallmean = gpd_hdd['fuel_consumption'].mean()
        gpd_hdd3 = pd.merge(gpd_hdd2, mm, on='month', how='left')
        gpd_hdd3.index = gpd_hdd2.index

        gpd_hdd3.loc[pd.isnull(gpd_hdd3['fuel_consumption']),'fuel_consumption'] = gpd_hdd3.loc[pd.isnull(gpd_hdd3['fuel_consumption']),'mm']
        gpd_hdd3.loc[pd.isnull(gpd_hdd3['fuel_consumption']),'fuel_consumption'] =  overallmean


        estimated = gpd_hdd3[['fuel_consumption']].groupby(pd.Grouper(freq='M')).agg(['sum', 'count'])
        estimated.columns = ['total_fuel','day_count']
        #join it with original to keep sample sizes
        monthSummary = pd.concat([estimated,self.actualAverageGallonsPerHDDByMonth], axis=1)
        return monthSummary


    def filterDataset(self):
        '''
        Read in the unified netcdf and generate dataframes of the necessary report data

        :return: DataFrame filtered to report time period
        :return: DataFrame filtered to earliest possible date up to end of report time period
        '''

        #start with a netcdf file generated from Data.puma2unified
        uni_nc = Dataset(self.unified_nc_file,'r')
        if not self.stoves:
            self.mergeStoves()
        timezone = pytz.timezone('US/Alaska')
        #list of dataframes generated from each stove read in
        def makeCombinedDataframe(s):
            try:
                # event_df = pd.DataFrame({
                #               'fuel_consumption': uni_nc[s + '/Event/Clicks']['fuel_consumption'][:],
                #               'gph': uni_nc[s + '/Event/Clicks']['fuel_consumption_rate'][:],
                #               'clicks': uni_nc[s + '/Event/Clicks']['clicks'][:],
                #                 'inT': uni_nc[s + '/Event/Clicks']['indoor_temp'][:],
                #               'stove': [s] * len(uni_nc[s + '/Event/Clicks']['time'][:])
                #               },
                #              index=pd.to_datetime(uni_nc[s + '/Event/Clicks']['time'][:],unit='s',utc=True))
                event_df = pd.DataFrame({
                              'fuel_consumption': uni_nc[s + '/Event/Clicks']['fuel_consumption'][:],
                              'gph': uni_nc[s + '/Event/Clicks']['fuel_consumption_rate'][:],
                              'clicks': uni_nc[s + '/Event/Clicks']['clicks'][:],
                                'inT': uni_nc[s + '/Event/Clicks']['indoor_temp'][:],
                              'stove': [s] * len(uni_nc[s + '/Event/Clicks']['time'][:])
                              },
                             index=pd.to_datetime(uni_nc[s + '/Event/Clicks']['time'][:],utc=True, unit='s'))
            except KeyError as e:
                print(e)
                event_df = pd.DataFrame()
            try:
                timed_df = pd.DataFrame({'outT': uni_nc[s + '/Time']['outdoor_temp'][:],
                                'inT': uni_nc[s + '/Time']['indoor_temp'][:],
                                'deltaT':uni_nc[s + '/Time']['delta_temp'][:],
                                'stove': [s] * len(uni_nc[s + '/Time']['time'][:])},
                                        index=pd.to_datetime(uni_nc[s + '/Time']['time'][:],utc=True, unit='s'))
                # timed_df = pd.DataFrame({'outT': uni_nc[s + '/Time']['outdoor_temp'][:],
                #                          'inT': uni_nc[s + '/Time']['indoor_temp'][:],
                #                          'deltaT': uni_nc[s + '/Time']['delta_temp'][:],
                #                          'stove': [s] * len(uni_nc[s + '/Time']['time'][:])},
                #                         index=pd.to_datetime(uni_nc[s + '/Time']['time'][:], unit='s', utc=True))
            except KeyError as e:
                print(e)
                timed_df = pd.DataFrame()

            df = pd.concat([event_df,timed_df],axis=0)

            if len(df)>0:
                df.index = df.index.tz_convert(timezone) #convert to Alaska time so report reflects metrics based on local conditions
                df = df.sort_index(0)

            return df

        filtered_df_list = [makeCombinedDataframe(s.name) for s in self.stoves]

        filtered_df = pd.concat(filtered_df_list)
        self.hourlyOutdoorTemperature = self.getHourlyTemperature(filtered_df, 'outT')
        filtered_df = filtered_df.sort_index(0)
        studyStart = datetime.datetime.strptime('2019-09-01 00:00:00',"%Y-%m-%d %H:%M:%S")
        studyStart = timezone.localize(studyStart, timezone)
        dataStart = min(filtered_df[pd.notnull(filtered_df.deltaT)][studyStart:].index) #drop records that are earlier than our actual data collection
        filtered_df = filtered_df[dataStart:]
        #filter out days with fewer than 12 hours of data and fewer thand 20 days of data per month

        d = filtered_df[pd.notnull(filtered_df['fuel_consumption'])]
        dsum = d['fuel_consumption'].groupby(pd.Grouper(freq="D")).sum(min_count=1)
        daysWithClicks = dsum.groupby(pd.Grouper(
            freq="M")).count()  # if there are fewer than 15 days we don't want to extrapolate month long information
        daysWithClicks.name = 'day_with_clicks_count'

        d = filtered_df[pd.notnull(filtered_df['inT'])]
        dsum = d['inT'].groupby(pd.Grouper(freq="D")).sum(min_count=1)
        daysWithT = dsum.groupby(pd.Grouper(
            freq="M")).count()  # if there are fewer than 15 days we don't want to extrapolate month long information
        daysWithT.name = 'day_with_Temperature_count'

        daysWithTooLittleData = self.getDaysWithLessThan12hours(filtered_df)
        daysWithTooLittleData.name = 'baddays'
        daysWithTooLittleData = pd.DataFrame(daysWithTooLittleData, index=daysWithTooLittleData.index.date)

        daysWithTooLittleData.loc[pd.isnull(daysWithTooLittleData['baddays'])] = pd.to_timedelta('0h')

        f =   pd.merge(filtered_df, daysWithTooLittleData, how='left', left_on=filtered_df.index.date,
                     right_on=daysWithTooLittleData.index)
        f.index = filtered_df.index
        filtered_df = f.loc[pd.isnull(f['baddays']),]

        filtered_df = filtered_df[(pd.notnull(filtered_df['fuel_consumption']) | (pd.notnull(filtered_df['inT'])))] #only days with fuel data - either clicks or temperature

        filtered_df = filtered_df.drop(['key_0','baddays'],axis=1)
        gooddata = self.removeShortMonths(filtered_df)
        return gooddata[studyStart:self.end], filtered_df[studyStart:self.end] #all records up to end date

    def findImage(self,path,name):
        filenames = [f for f in os.listdir(path) if (name in f) & (f[-3:] == "png")]
        if (len(filenames) > 0):
            filename = filenames[0]
            return os.path.join(path, filename)
        return
    def findSpatialImage(self, name):
        path = os.path.join(*["..","..","R","Spatial"])
        return self.findImage(path,name)

    def findTemperatureImage(self, name):
        path = os.path.join(*["..", "..", "R"])
        return self.findImage(path, name)

    def copyfile(self,source, destination):
        shutil.move(source,destination)
        return
    def moveModelImages(self, ReportDirectory):
        spatial_image = self.findSpatialImage(self.name)
        temperature_image = self.findTemperatureImage(self.name)
        newName = os.path.join(ReportDirectory, os.path.basename(spatial_image)[len(self.name):])
        self.copyfile(spatial_image,newName)
        newName = os.path.join(ReportDirectory, os.path.basename(temperature_image)[len(self.name):])
        self.copyfile(temperature_image, newName)


class MonthlyReport(Report):
    '''Monthly Report is a subclass of Report with custom functions for writing report text and calculating month specific metrics'''
    def __init__(self,start,end,title,nc,houses,fuel_price):
        super(MonthlyReport, self).__init__(start,end,title,nc,houses,fuel_price)
        if isinstance(fuel_price,pd.Series):
            self.fuel_price = fuel_price[start:end].mean()

    def getAveTemperature(self, t_data):
        allMonths = super().getAveTemperature(t_data) #allMonths is a tuple with dataframe as first record

        return allMonths[0], allMonths[1] #the ave and sem for month of report

    def calculated_monthly_data(self):

        self.filtered_df.hdd = ptemp.heat_degree_day(pd.filtered_df,65)

        self.filtered_df.gphddpm = pfuel.run_weather_adjusted_gallons_per_month(pd.Series(self.filtered_df.index),self.filtered_df.gallons,self.filtered_df.hdd)

        return
    def isFirstMonth(self):
        try:
            tr = pd.date_range(self.unfiltered_df.index[0],self.unfiltered_df.index[-1],freq = 'M')
            if self.start > tr[1]:
                return False
            return True
        except:
            return True
    def writeReport(self):
        os.chdir(self.name)

        ptex.write_monthly_tex_var_file(pd.date_range(self.start, self.end, freq = 'D'),
                                        self.total_gallons,
                                        self.gallons_per_ft,
                                        self.fuel_price,
                                        self.ave_fuel_per_day[0],
                                        self.total_cost,
                                        self.ave_cost_per_day,
                                        self.neighbor_usage_per_area[0],
                                        self.prog_usage,
                                        self.name,
                                        self.ave_MonthlyindoorT['ave'],
                                        self.ave_MonthlyoutdoorT['ave'],
                                        self.tip_no,
                                        self.dataFlag,
                                        self.days_monitored[1],
                                        len(self.neighborhood.houses)
                                        )

        #if this is the first report for the dataset don't compare to anything
        #otherwise compare to the previous month
        if self.isFirstMonth():
            ptex.write_monthly_tex_report_file(self.name, pd.date_range(self.start, self.end, freq = 'D'),None)
        else:
            ptex.write_monthly_tex_report_file(self.name, pd.date_range(self.start, self.end, freq='D'), pd.date_range(self.end, periods = 1,freq='M'))

        os.chdir('..')
    def getTip(self):
        self.getMonthlyTip()

    def getMonthlyTip(self):
        #assuming month 9 was tip 0
        self.tip_no = self.start.month + 3

    def makePlots(self):
        '''produces pngs of plots specific to this report'''
        os.chdir(self.name)
        pplot.plot_bar_progress(self.gphddBym,
                                'monthly_track_your_progress.png')


        pplot.plot_fuel_usage(self.gallons_per_ft, self.neighbor_usage_per_area[0], 'monthly_fuel_usage.png')

        pplot.polar_flow_plot_per_month_df(self.name,self.ave_gallons_by_hour,
                                                'monthly_polar_plot.png')
        os.chdir("..")

